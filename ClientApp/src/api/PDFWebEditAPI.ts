//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.18.2.0 (NJsonSchema v10.8.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export module PDFWebEditAPI {
export const BASE_URL = new InjectionToken<string>('BASE_URL');

@Injectable({
    providedIn: 'root'
})
export class ConfigurationClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * Gets the configuration.
     * @return The configuration.
     */
    getConfiguration(): Observable<Config | null> {
        let url_ = this.baseUrl + "/api/configuration";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetConfiguration(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetConfiguration(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Config | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Config | null>;
        }));
    }

    protected processGetConfiguration(response: HttpResponseBase): Observable<Config | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Config.fromJS(resultData200) : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? ProblemDetails.fromJS(resultData500) : <any>null;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Config | null>(null as any);
    }

    /**
     * Saves a configuration.
     * @param config The configuration.
     * @return The updated config
     */
    saveConfiguration(config: Config): Observable<Config | null> {
        let url_ = this.baseUrl + "/api/configuration";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(config);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveConfiguration(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveConfiguration(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Config | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Config | null>;
        }));
    }

    protected processSaveConfiguration(response: HttpResponseBase): Observable<Config | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Config.fromJS(resultData200) : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? ProblemDetails.fromJS(resultData500) : <any>null;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Config | null>(null as any);
    }

    /**
     * Reload configuration.
     * @return A status code indicating success or failure.
     */
    reloadConfiguration(): Observable<Config | null> {
        let url_ = this.baseUrl + "/api/configuration";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReloadConfiguration(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReloadConfiguration(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Config | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Config | null>;
        }));
    }

    protected processReloadConfiguration(response: HttpResponseBase): Observable<Config | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Config.fromJS(resultData200) : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? ProblemDetails.fromJS(resultData500) : <any>null;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Config | null>(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class DocumentClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * Gets the directories in this collection.
     * @return An enumerator that allows foreach to be used to process the directories in this collection.
     */
    getDirectories(): Observable<Folder[] | null> {
        let url_ = this.baseUrl + "/api/documents/directories";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDirectories(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDirectories(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Folder[] | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Folder[] | null>;
        }));
    }

    protected processGetDirectories(response: HttpResponseBase): Observable<Folder[] | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Folder.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? ProblemDetails.fromJS(resultData500) : <any>null;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Folder[] | null>(null as any);
    }

    /**
     * Gets the documents in the selected folder.
     * @param targetDirectory The target directory.
     * @return An enumerator that allows foreach to be used to process the documents in this collection.
     */
    getDocuments(targetDirectory: TargetDirectory): Observable<Document[] | null> {
        let url_ = this.baseUrl + "/api/documents/list/{targetDirectory}";
        if (targetDirectory === undefined || targetDirectory === null)
            throw new Error("The parameter 'targetDirectory' must be defined.");
        url_ = url_.replace("{targetDirectory}", encodeURIComponent("" + targetDirectory));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDocuments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDocuments(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Document[] | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Document[] | null>;
        }));
    }

    protected processGetDocuments(response: HttpResponseBase): Observable<Document[] | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Document.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? ProblemDetails.fromJS(resultData500) : <any>null;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Document[] | null>(null as any);
    }

    /**
     * Gets a document.
     * @param targetDirectory The target directory.
     * @param document The document.
     * @param subDirectory (optional) The sub directory containing the document.
     * @return The document.
     */
    getDocument(targetDirectory: TargetDirectory, document: string, subDirectory?: string | null | undefined): Observable<Document | null> {
        let url_ = this.baseUrl + "/api/documents/list/{targetDirectory}/{document}?";
        if (targetDirectory === undefined || targetDirectory === null)
            throw new Error("The parameter 'targetDirectory' must be defined.");
        url_ = url_.replace("{targetDirectory}", encodeURIComponent("" + targetDirectory));
        if (document === undefined || document === null)
            throw new Error("The parameter 'document' must be defined.");
        url_ = url_.replace("{document}", encodeURIComponent("" + document));
        if (subDirectory !== undefined && subDirectory !== null)
            url_ += "subDirectory=" + encodeURIComponent("" + subDirectory) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDocument(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDocument(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Document | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Document | null>;
        }));
    }

    protected processGetDocument(response: HttpResponseBase): Observable<Document | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Document.fromJS(resultData200) : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? ProblemDetails.fromJS(resultData500) : <any>null;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Document | null>(null as any);
    }

    /**
     * Gets a document.
     * @param targetDirectory The target directory.
     * @param document The document.
     * @param subDirectory (optional) The sub directory containing the document.
     * @return The document.
     */
    downloadDocument(targetDirectory: TargetDirectory, document: string, subDirectory?: string | null | undefined): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/documents/{targetDirectory}/{document}/download?";
        if (targetDirectory === undefined || targetDirectory === null)
            throw new Error("The parameter 'targetDirectory' must be defined.");
        url_ = url_.replace("{targetDirectory}", encodeURIComponent("" + targetDirectory));
        if (document === undefined || document === null)
            throw new Error("The parameter 'document' must be defined.");
        url_ = url_.replace("{document}", encodeURIComponent("" + document));
        if (subDirectory !== undefined && subDirectory !== null)
            url_ += "subDirectory=" + encodeURIComponent("" + subDirectory) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDownloadDocument(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownloadDocument(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processDownloadDocument(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? ProblemDetails.fromJS(resultData500) : <any>null;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse | null>(null as any);
    }

    /**
     * Gets page count of the specified document.
     * @param targetDirectory The target directory.
     * @param document The document.
     * @param subDirectory (optional) The sub directory containing the document.
     * @return The page count.
     */
    getPageCount(targetDirectory: TargetDirectory, document: string, subDirectory?: string | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/documents/{targetDirectory}/{document}/page-count?";
        if (targetDirectory === undefined || targetDirectory === null)
            throw new Error("The parameter 'targetDirectory' must be defined.");
        url_ = url_.replace("{targetDirectory}", encodeURIComponent("" + targetDirectory));
        if (document === undefined || document === null)
            throw new Error("The parameter 'document' must be defined.");
        url_ = url_.replace("{document}", encodeURIComponent("" + document));
        if (subDirectory !== undefined && subDirectory !== null)
            url_ += "subDirectory=" + encodeURIComponent("" + subDirectory) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPageCount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPageCount(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processGetPageCount(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? ProblemDetails.fromJS(resultData500) : <any>null;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    /**
     * Gets page preview in the specified document.
     * @param targetDirectory The target directory.
     * @param document The document.
     * @param pageNumber The page number (starting at 1).
     * @param width The page width.
     * @param height The page height.
     * @param subDirectory (optional) The sub directory containing the document.
     * @return The page preview.
     */
    getPagePreview(targetDirectory: TargetDirectory, document: string, pageNumber: number, width: number, height: number, subDirectory?: string | null | undefined): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/documents/{targetDirectory}/{document}/preview/{pageNumber}?";
        if (targetDirectory === undefined || targetDirectory === null)
            throw new Error("The parameter 'targetDirectory' must be defined.");
        url_ = url_.replace("{targetDirectory}", encodeURIComponent("" + targetDirectory));
        if (document === undefined || document === null)
            throw new Error("The parameter 'document' must be defined.");
        url_ = url_.replace("{document}", encodeURIComponent("" + document));
        if (pageNumber === undefined || pageNumber === null)
            throw new Error("The parameter 'pageNumber' must be defined.");
        url_ = url_.replace("{pageNumber}", encodeURIComponent("" + pageNumber));
        if (width === undefined || width === null)
            throw new Error("The parameter 'width' must be defined and cannot be null.");
        else
            url_ += "width=" + encodeURIComponent("" + width) + "&";
        if (height === undefined || height === null)
            throw new Error("The parameter 'height' must be defined and cannot be null.");
        else
            url_ += "height=" + encodeURIComponent("" + height) + "&";
        if (subDirectory !== undefined && subDirectory !== null)
            url_ += "subDirectory=" + encodeURIComponent("" + subDirectory) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPagePreview(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPagePreview(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processGetPagePreview(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? ProblemDetails.fromJS(resultData500) : <any>null;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse | null>(null as any);
    }

    /**
     * Renames a document.
     * @param targetDirectory The target directory.
     * @param document The document.
     * @param newDocumentName New name of the document.
     * @param subDirectory (optional) The sub directory containing the document.
     * @return An IActionResult.
     */
    rename(targetDirectory: TargetDirectory, document: string, newDocumentName: string, subDirectory?: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/documents/{targetDirectory}/{document}/rename/{newDocumentName}?";
        if (targetDirectory === undefined || targetDirectory === null)
            throw new Error("The parameter 'targetDirectory' must be defined.");
        url_ = url_.replace("{targetDirectory}", encodeURIComponent("" + targetDirectory));
        if (document === undefined || document === null)
            throw new Error("The parameter 'document' must be defined.");
        url_ = url_.replace("{document}", encodeURIComponent("" + document));
        if (newDocumentName === undefined || newDocumentName === null)
            throw new Error("The parameter 'newDocumentName' must be defined.");
        url_ = url_.replace("{newDocumentName}", encodeURIComponent("" + newDocumentName));
        if (subDirectory !== undefined && subDirectory !== null)
            url_ += "subDirectory=" + encodeURIComponent("" + subDirectory) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRename(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRename(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processRename(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? ProblemDetails.fromJS(resultData500) : <any>null;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * Rotates pages in the specified document clockwise.
     * @param targetDirectory The target directory.
     * @param document The document.
     * @param pageNumbers The page numbers (1-based).
     * @param subDirectory (optional) The sub directory containing the document.
     * @return An IActionResult.
     */
    rotatePagesClockwise(targetDirectory: TargetDirectory, document: string, pageNumbers: number[], subDirectory?: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/documents/{targetDirectory}/{document}/rotate-pages-clockwise?";
        if (targetDirectory === undefined || targetDirectory === null)
            throw new Error("The parameter 'targetDirectory' must be defined.");
        url_ = url_.replace("{targetDirectory}", encodeURIComponent("" + targetDirectory));
        if (document === undefined || document === null)
            throw new Error("The parameter 'document' must be defined.");
        url_ = url_.replace("{document}", encodeURIComponent("" + document));
        if (subDirectory !== undefined && subDirectory !== null)
            url_ += "subDirectory=" + encodeURIComponent("" + subDirectory) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(pageNumbers);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRotatePagesClockwise(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRotatePagesClockwise(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processRotatePagesClockwise(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? ProblemDetails.fromJS(resultData500) : <any>null;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * Rotate pages in the specified document anti clockwise.
     * @param targetDirectory The target directory.
     * @param document The document.
     * @param pageNumbers The page numbers (1-based).
     * @param subDirectory (optional) The sub directory containing the document.
     * @return An IActionResult.
     */
    rotatePagesAntiClockwise(targetDirectory: TargetDirectory, document: string, pageNumbers: number[], subDirectory?: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/documents/{targetDirectory}/{document}/rotate-pages-anti-clockwise?";
        if (targetDirectory === undefined || targetDirectory === null)
            throw new Error("The parameter 'targetDirectory' must be defined.");
        url_ = url_.replace("{targetDirectory}", encodeURIComponent("" + targetDirectory));
        if (document === undefined || document === null)
            throw new Error("The parameter 'document' must be defined.");
        url_ = url_.replace("{document}", encodeURIComponent("" + document));
        if (subDirectory !== undefined && subDirectory !== null)
            url_ += "subDirectory=" + encodeURIComponent("" + subDirectory) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(pageNumbers);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRotatePagesAntiClockwise(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRotatePagesAntiClockwise(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processRotatePagesAntiClockwise(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? ProblemDetails.fromJS(resultData500) : <any>null;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * Deletes the pages in the specified document.
     * @param targetDirectory The target directory.
     * @param document The document.
     * @param pageNumbers The page numbers (1-based).
     * @param subDirectory (optional) The sub directory containing the document.
     * @return An IActionResult.
     */
    deletePages(targetDirectory: TargetDirectory, document: string, pageNumbers: number[], subDirectory?: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/documents/{targetDirectory}/{document}/delete-pages?";
        if (targetDirectory === undefined || targetDirectory === null)
            throw new Error("The parameter 'targetDirectory' must be defined.");
        url_ = url_.replace("{targetDirectory}", encodeURIComponent("" + targetDirectory));
        if (document === undefined || document === null)
            throw new Error("The parameter 'document' must be defined.");
        url_ = url_.replace("{document}", encodeURIComponent("" + document));
        if (subDirectory !== undefined && subDirectory !== null)
            url_ += "subDirectory=" + encodeURIComponent("" + subDirectory) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(pageNumbers);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeletePages(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeletePages(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeletePages(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? ProblemDetails.fromJS(resultData500) : <any>null;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * Reorder pages in the specified document.
     * @param targetDirectory The target directory.
     * @param document The document.
     * @param newPageOrder The new page order.
     * @param subDirectory (optional) The sub directory containing the document.
     * @return An IActionResult.
     */
    reorderPages(targetDirectory: TargetDirectory, document: string, newPageOrder: number[], subDirectory?: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/documents/{targetDirectory}/{document}/reorder-pages?";
        if (targetDirectory === undefined || targetDirectory === null)
            throw new Error("The parameter 'targetDirectory' must be defined.");
        url_ = url_.replace("{targetDirectory}", encodeURIComponent("" + targetDirectory));
        if (document === undefined || document === null)
            throw new Error("The parameter 'document' must be defined.");
        url_ = url_.replace("{document}", encodeURIComponent("" + document));
        if (subDirectory !== undefined && subDirectory !== null)
            url_ += "subDirectory=" + encodeURIComponent("" + subDirectory) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(newPageOrder);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReorderPages(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReorderPages(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processReorderPages(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? ProblemDetails.fromJS(resultData500) : <any>null;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * Splits the pages into a new document.
     * @param targetDirectory The target directory.
     * @param document The document.
     * @param pages The pages.
     * @param subDirectory (optional) The sub directory containing the document.
     * @return An IActionResult.
     */
    splitPages(targetDirectory: TargetDirectory, document: string, pages: number[], subDirectory?: string | null | undefined): Observable<Document | null> {
        let url_ = this.baseUrl + "/api/documents/{targetDirectory}/{document}/split-pages?";
        if (targetDirectory === undefined || targetDirectory === null)
            throw new Error("The parameter 'targetDirectory' must be defined.");
        url_ = url_.replace("{targetDirectory}", encodeURIComponent("" + targetDirectory));
        if (document === undefined || document === null)
            throw new Error("The parameter 'document' must be defined.");
        url_ = url_.replace("{document}", encodeURIComponent("" + document));
        if (subDirectory !== undefined && subDirectory !== null)
            url_ += "subDirectory=" + encodeURIComponent("" + subDirectory) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(pages);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSplitPages(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSplitPages(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Document | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Document | null>;
        }));
    }

    protected processSplitPages(response: HttpResponseBase): Observable<Document | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Document.fromJS(resultData200) : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? ProblemDetails.fromJS(resultData500) : <any>null;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Document | null>(null as any);
    }

    /**
     * Merges another document into the defined document.
     * @param targetDirectory The target directory.
     * @param document The document.
     * @param mergeDocument The merge document.
     * @param subDirectory (optional) The sub directory containing the document.
     * @param mergeDocumentSubDirectory (optional) Pathname of the merge document sub directory.
     * @return An IActionResult.
     */
    merge(targetDirectory: TargetDirectory, document: string, mergeDocument: string, subDirectory?: string | null | undefined, mergeDocumentSubDirectory?: string | null | undefined): Observable<Document | null> {
        let url_ = this.baseUrl + "/api/documents/{targetDirectory}/{document}/merge/{mergeDocument}?";
        if (targetDirectory === undefined || targetDirectory === null)
            throw new Error("The parameter 'targetDirectory' must be defined.");
        url_ = url_.replace("{targetDirectory}", encodeURIComponent("" + targetDirectory));
        if (document === undefined || document === null)
            throw new Error("The parameter 'document' must be defined.");
        url_ = url_.replace("{document}", encodeURIComponent("" + document));
        if (mergeDocument === undefined || mergeDocument === null)
            throw new Error("The parameter 'mergeDocument' must be defined.");
        url_ = url_.replace("{mergeDocument}", encodeURIComponent("" + mergeDocument));
        if (subDirectory !== undefined && subDirectory !== null)
            url_ += "subDirectory=" + encodeURIComponent("" + subDirectory) + "&";
        if (mergeDocumentSubDirectory !== undefined && mergeDocumentSubDirectory !== null)
            url_ += "mergeDocumentSubDirectory=" + encodeURIComponent("" + mergeDocumentSubDirectory) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMerge(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMerge(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Document | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Document | null>;
        }));
    }

    protected processMerge(response: HttpResponseBase): Observable<Document | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Document.fromJS(resultData200) : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? ProblemDetails.fromJS(resultData500) : <any>null;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Document | null>(null as any);
    }

    /**
     * Revert changes to the specified document.
     * @param targetDirectory The target directory.
     * @param document The document.
     * @param subDirectory (optional) The sub directory containing the document.
     * @return An IActionResult.
     */
    revertChanges(targetDirectory: TargetDirectory, document: string, subDirectory?: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/documents/{targetDirectory}/{document}/revert?";
        if (targetDirectory === undefined || targetDirectory === null)
            throw new Error("The parameter 'targetDirectory' must be defined.");
        url_ = url_.replace("{targetDirectory}", encodeURIComponent("" + targetDirectory));
        if (document === undefined || document === null)
            throw new Error("The parameter 'document' must be defined.");
        url_ = url_.replace("{document}", encodeURIComponent("" + document));
        if (subDirectory !== undefined && subDirectory !== null)
            url_ += "subDirectory=" + encodeURIComponent("" + subDirectory) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRevertChanges(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRevertChanges(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processRevertChanges(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? ProblemDetails.fromJS(resultData500) : <any>null;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * Archives the specified document.
     * @param targetDirectory The target directory.
     * @param document The document.
     * @param subDirectory (optional) The sub directory containing the document.
     * @return An IActionResult.
     */
    archive(targetDirectory: TargetDirectory, document: string, subDirectory?: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/documents/{targetDirectory}/{document}/archive?";
        if (targetDirectory === undefined || targetDirectory === null)
            throw new Error("The parameter 'targetDirectory' must be defined.");
        url_ = url_.replace("{targetDirectory}", encodeURIComponent("" + targetDirectory));
        if (document === undefined || document === null)
            throw new Error("The parameter 'document' must be defined.");
        url_ = url_.replace("{document}", encodeURIComponent("" + document));
        if (subDirectory !== undefined && subDirectory !== null)
            url_ += "subDirectory=" + encodeURIComponent("" + subDirectory) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processArchive(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processArchive(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processArchive(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? ProblemDetails.fromJS(resultData500) : <any>null;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * Permentently deletes the specified document from the archive.
     * @param document The document.
     * @return An IActionResult.
     */
    deleteFromArchive(document: string): Observable<void> {
        let url_ = this.baseUrl + "/api/documents/{document}/delete";
        if (document === undefined || document === null)
            throw new Error("The parameter 'document' must be defined.");
        url_ = url_.replace("{document}", encodeURIComponent("" + document));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteFromArchive(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteFromArchive(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteFromArchive(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? ProblemDetails.fromJS(resultData500) : <any>null;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * Unlocks the document.
     * @param targetDirectory The target directory.
     * @param document The document.
     * @param password The password.
     * @param subDirectory (optional) The sub directory containing the document.
     * @return An IActionResult.
     */
    unlock(targetDirectory: TargetDirectory, document: string, password: string, subDirectory?: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/documents/{targetDirectory}/{document}/unlock?";
        if (targetDirectory === undefined || targetDirectory === null)
            throw new Error("The parameter 'targetDirectory' must be defined.");
        url_ = url_.replace("{targetDirectory}", encodeURIComponent("" + targetDirectory));
        if (document === undefined || document === null)
            throw new Error("The parameter 'document' must be defined.");
        url_ = url_.replace("{document}", encodeURIComponent("" + document));
        if (password === undefined || password === null)
            throw new Error("The parameter 'password' must be defined and cannot be null.");
        else
            url_ += "password=" + encodeURIComponent("" + password) + "&";
        if (subDirectory !== undefined && subDirectory !== null)
            url_ += "subDirectory=" + encodeURIComponent("" + subDirectory) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUnlock(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUnlock(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUnlock(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? ProblemDetails.fromJS(resultData500) : <any>null;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * Restores a document from the target directory to the inbox.
     * @param targetDirectory The target directory.
     * @param document The document.
     * @param subDirectory (optional) The sub directory containing the document.
     * @return An IActionResult.
     */
    restore(targetDirectory: TargetDirectory, document: string, subDirectory?: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/documents/{document}/restore?";
        if (document === undefined || document === null)
            throw new Error("The parameter 'document' must be defined.");
        url_ = url_.replace("{document}", encodeURIComponent("" + document));
        if (targetDirectory === undefined || targetDirectory === null)
            throw new Error("The parameter 'targetDirectory' must be defined and cannot be null.");
        else
            url_ += "targetDirectory=" + encodeURIComponent("" + targetDirectory) + "&";
        if (subDirectory !== undefined && subDirectory !== null)
            url_ += "subDirectory=" + encodeURIComponent("" + subDirectory) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRestore(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRestore(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processRestore(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? ProblemDetails.fromJS(resultData500) : <any>null;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * Saves the specified document from the inbox directory.
     * @param document The document.
     * @param sourceSubDirectory (optional) The subDirectory to move from.
     * @param targetSubDirectory (optional) The subDirectory to save to.
     * @return An IActionResult.
     */
    saveTo(document: string, sourceSubDirectory?: string | null | undefined, targetSubDirectory?: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/documents/{document}/saveto?";
        if (document === undefined || document === null)
            throw new Error("The parameter 'document' must be defined.");
        url_ = url_.replace("{document}", encodeURIComponent("" + document));
        if (sourceSubDirectory !== undefined && sourceSubDirectory !== null)
            url_ += "sourceSubDirectory=" + encodeURIComponent("" + sourceSubDirectory) + "&";
        if (targetSubDirectory !== undefined && targetSubDirectory !== null)
            url_ += "targetSubDirectory=" + encodeURIComponent("" + targetSubDirectory) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveTo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveTo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSaveTo(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? ProblemDetails.fromJS(resultData500) : <any>null;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * Saves the specified document from the inbox directory.
     * @param document The document.
     * @param sourceSubDirectory (optional) The subDirectory to move from.
     * @return An IActionResult.
     */
    save(document: string, sourceSubDirectory?: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/documents/{document}/save?";
        if (document === undefined || document === null)
            throw new Error("The parameter 'document' must be defined.");
        url_ = url_.replace("{document}", encodeURIComponent("" + document));
        if (sourceSubDirectory !== undefined && sourceSubDirectory !== null)
            url_ += "sourceSubDirectory=" + encodeURIComponent("" + sourceSubDirectory) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSave(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSave(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSave(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? ProblemDetails.fromJS(resultData500) : <any>null;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

/** A configuration. */
export class Config implements IConfig {
    /** Gets or sets the header configuration. */
    headerConfig!: HeaderConfig;
    /** Gets or sets the general configuration. */
    generalConfig!: GeneralConfig;
    /** Gets or sets the preview configuration. */
    previewConfig!: PreviewConfig;
    /** Gets or sets the inbox configuration. */
    inboxConfig!: InboxConfig;
    /** Gets or sets the outbox configuration. */
    outboxConfig!: OutboxConfig;
    /** Gets or sets the archive configuration. */
    archiveConfig!: ArchiveConfig;

    constructor(data?: IConfig) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.headerConfig = new HeaderConfig();
            this.generalConfig = new GeneralConfig();
            this.previewConfig = new PreviewConfig();
            this.inboxConfig = new InboxConfig();
            this.outboxConfig = new OutboxConfig();
            this.archiveConfig = new ArchiveConfig();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.headerConfig = _data["headerConfig"] ? HeaderConfig.fromJS(_data["headerConfig"]) : new HeaderConfig();
            this.generalConfig = _data["generalConfig"] ? GeneralConfig.fromJS(_data["generalConfig"]) : new GeneralConfig();
            this.previewConfig = _data["previewConfig"] ? PreviewConfig.fromJS(_data["previewConfig"]) : new PreviewConfig();
            this.inboxConfig = _data["inboxConfig"] ? InboxConfig.fromJS(_data["inboxConfig"]) : new InboxConfig();
            this.outboxConfig = _data["outboxConfig"] ? OutboxConfig.fromJS(_data["outboxConfig"]) : new OutboxConfig();
            this.archiveConfig = _data["archiveConfig"] ? ArchiveConfig.fromJS(_data["archiveConfig"]) : new ArchiveConfig();
        }
    }

    static fromJS(data: any): Config {
        data = typeof data === 'object' ? data : {};
        let result = new Config();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["headerConfig"] = this.headerConfig ? this.headerConfig.toJSON() : <any>null;
        data["generalConfig"] = this.generalConfig ? this.generalConfig.toJSON() : <any>null;
        data["previewConfig"] = this.previewConfig ? this.previewConfig.toJSON() : <any>null;
        data["inboxConfig"] = this.inboxConfig ? this.inboxConfig.toJSON() : <any>null;
        data["outboxConfig"] = this.outboxConfig ? this.outboxConfig.toJSON() : <any>null;
        data["archiveConfig"] = this.archiveConfig ? this.archiveConfig.toJSON() : <any>null;
        return data;
    }
}

/** A configuration. */
export interface IConfig {
    /** Gets or sets the header configuration. */
    headerConfig: HeaderConfig;
    /** Gets or sets the general configuration. */
    generalConfig: GeneralConfig;
    /** Gets or sets the preview configuration. */
    previewConfig: PreviewConfig;
    /** Gets or sets the inbox configuration. */
    inboxConfig: InboxConfig;
    /** Gets or sets the outbox configuration. */
    outboxConfig: OutboxConfig;
    /** Gets or sets the archive configuration. */
    archiveConfig: ArchiveConfig;
}

/** A header configuration. */
export class HeaderConfig implements IHeaderConfig {
    /** Gets or sets a value indicating whether the search is shown. */
    showSearch!: boolean;
    /** Gets or sets a value indicating whether the directory picker is shown. */
    showDirectoryPicker!: boolean;
    /** Gets or sets a value indicating whether the preview size picker is shown. */
    showPreviewSizePicker!: boolean;
    /** Gets or sets a value indicating whether the sort picker is shown. */
    showSortPicker!: boolean;
    /** Gets or sets a value indicating whether the colour mode picker is shown. */
    showColourModePicker!: boolean;
    /** Gets or sets a value indicating whether the settings button is shown. */
    showSettingsButton!: boolean;
    /** Gets or sets a value indicating whether the icons is shown. */
    showIcons!: boolean;
    /** Gets or sets a value indicating whether the labels is shown. */
    showLabels!: boolean;

    constructor(data?: IHeaderConfig) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.showSearch = _data["showSearch"] !== undefined ? _data["showSearch"] : <any>null;
            this.showDirectoryPicker = _data["showDirectoryPicker"] !== undefined ? _data["showDirectoryPicker"] : <any>null;
            this.showPreviewSizePicker = _data["showPreviewSizePicker"] !== undefined ? _data["showPreviewSizePicker"] : <any>null;
            this.showSortPicker = _data["showSortPicker"] !== undefined ? _data["showSortPicker"] : <any>null;
            this.showColourModePicker = _data["showColourModePicker"] !== undefined ? _data["showColourModePicker"] : <any>null;
            this.showSettingsButton = _data["showSettingsButton"] !== undefined ? _data["showSettingsButton"] : <any>null;
            this.showIcons = _data["showIcons"] !== undefined ? _data["showIcons"] : <any>null;
            this.showLabels = _data["showLabels"] !== undefined ? _data["showLabels"] : <any>null;
        }
    }

    static fromJS(data: any): HeaderConfig {
        data = typeof data === 'object' ? data : {};
        let result = new HeaderConfig();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["showSearch"] = this.showSearch !== undefined ? this.showSearch : <any>null;
        data["showDirectoryPicker"] = this.showDirectoryPicker !== undefined ? this.showDirectoryPicker : <any>null;
        data["showPreviewSizePicker"] = this.showPreviewSizePicker !== undefined ? this.showPreviewSizePicker : <any>null;
        data["showSortPicker"] = this.showSortPicker !== undefined ? this.showSortPicker : <any>null;
        data["showColourModePicker"] = this.showColourModePicker !== undefined ? this.showColourModePicker : <any>null;
        data["showSettingsButton"] = this.showSettingsButton !== undefined ? this.showSettingsButton : <any>null;
        data["showIcons"] = this.showIcons !== undefined ? this.showIcons : <any>null;
        data["showLabels"] = this.showLabels !== undefined ? this.showLabels : <any>null;
        return data;
    }
}

/** A header configuration. */
export interface IHeaderConfig {
    /** Gets or sets a value indicating whether the search is shown. */
    showSearch: boolean;
    /** Gets or sets a value indicating whether the directory picker is shown. */
    showDirectoryPicker: boolean;
    /** Gets or sets a value indicating whether the preview size picker is shown. */
    showPreviewSizePicker: boolean;
    /** Gets or sets a value indicating whether the sort picker is shown. */
    showSortPicker: boolean;
    /** Gets or sets a value indicating whether the colour mode picker is shown. */
    showColourModePicker: boolean;
    /** Gets or sets a value indicating whether the settings button is shown. */
    showSettingsButton: boolean;
    /** Gets or sets a value indicating whether the icons is shown. */
    showIcons: boolean;
    /** Gets or sets a value indicating whether the labels is shown. */
    showLabels: boolean;
}

/** A general configuration. */
export class GeneralConfig implements IGeneralConfig {
    /** Gets or sets a value indicating whether the tour is enabled. */
    enableTour!: boolean;
    /** Gets or sets the default folder. */
    defaultFolder!: string;
    /** Gets or sets the default sort column. */
    defaultSortColumn!: string;
    /** Gets or sets the default sort direction. */
    defaultSortDirection!: string;
    /** Gets or sets a value indicating whether to make the header sticky. */
    stickyHeader!: boolean;
    /** Gets or sets a value indicating whether the icons is shown. */
    showIcons!: boolean;
    /** Gets or sets a value indicating whether the labels is shown. */
    showLabels!: boolean;
    /** Gets or sets the default colour mode. */
    defaultColourMode!: string;
    /** Gets or sets a value indicating whether the debug mode. */
    debugMode!: boolean;

    constructor(data?: IGeneralConfig) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.enableTour = _data["enableTour"] !== undefined ? _data["enableTour"] : <any>null;
            this.defaultFolder = _data["defaultFolder"] !== undefined ? _data["defaultFolder"] : <any>null;
            this.defaultSortColumn = _data["defaultSortColumn"] !== undefined ? _data["defaultSortColumn"] : <any>null;
            this.defaultSortDirection = _data["defaultSortDirection"] !== undefined ? _data["defaultSortDirection"] : <any>null;
            this.stickyHeader = _data["stickyHeader"] !== undefined ? _data["stickyHeader"] : <any>null;
            this.showIcons = _data["showIcons"] !== undefined ? _data["showIcons"] : <any>null;
            this.showLabels = _data["showLabels"] !== undefined ? _data["showLabels"] : <any>null;
            this.defaultColourMode = _data["defaultColourMode"] !== undefined ? _data["defaultColourMode"] : <any>null;
            this.debugMode = _data["debugMode"] !== undefined ? _data["debugMode"] : <any>null;
        }
    }

    static fromJS(data: any): GeneralConfig {
        data = typeof data === 'object' ? data : {};
        let result = new GeneralConfig();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["enableTour"] = this.enableTour !== undefined ? this.enableTour : <any>null;
        data["defaultFolder"] = this.defaultFolder !== undefined ? this.defaultFolder : <any>null;
        data["defaultSortColumn"] = this.defaultSortColumn !== undefined ? this.defaultSortColumn : <any>null;
        data["defaultSortDirection"] = this.defaultSortDirection !== undefined ? this.defaultSortDirection : <any>null;
        data["stickyHeader"] = this.stickyHeader !== undefined ? this.stickyHeader : <any>null;
        data["showIcons"] = this.showIcons !== undefined ? this.showIcons : <any>null;
        data["showLabels"] = this.showLabels !== undefined ? this.showLabels : <any>null;
        data["defaultColourMode"] = this.defaultColourMode !== undefined ? this.defaultColourMode : <any>null;
        data["debugMode"] = this.debugMode !== undefined ? this.debugMode : <any>null;
        return data;
    }
}

/** A general configuration. */
export interface IGeneralConfig {
    /** Gets or sets a value indicating whether the tour is enabled. */
    enableTour: boolean;
    /** Gets or sets the default folder. */
    defaultFolder: string;
    /** Gets or sets the default sort column. */
    defaultSortColumn: string;
    /** Gets or sets the default sort direction. */
    defaultSortDirection: string;
    /** Gets or sets a value indicating whether to make the header sticky. */
    stickyHeader: boolean;
    /** Gets or sets a value indicating whether the icons is shown. */
    showIcons: boolean;
    /** Gets or sets a value indicating whether the labels is shown. */
    showLabels: boolean;
    /** Gets or sets the default colour mode. */
    defaultColourMode: string;
    /** Gets or sets a value indicating whether the debug mode. */
    debugMode: boolean;
}

/** A preview configuration. */
export class PreviewConfig implements IPreviewConfig {
    /** Gets or sets the default size. */
    defaultSize!: string;
    /** Gets or sets a value indicating whether the page number is shown. */
    showPageNumber!: boolean;

    constructor(data?: IPreviewConfig) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.defaultSize = _data["defaultSize"] !== undefined ? _data["defaultSize"] : <any>null;
            this.showPageNumber = _data["showPageNumber"] !== undefined ? _data["showPageNumber"] : <any>null;
        }
    }

    static fromJS(data: any): PreviewConfig {
        data = typeof data === 'object' ? data : {};
        let result = new PreviewConfig();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["defaultSize"] = this.defaultSize !== undefined ? this.defaultSize : <any>null;
        data["showPageNumber"] = this.showPageNumber !== undefined ? this.showPageNumber : <any>null;
        return data;
    }
}

/** A preview configuration. */
export interface IPreviewConfig {
    /** Gets or sets the default size. */
    defaultSize: string;
    /** Gets or sets a value indicating whether the page number is shown. */
    showPageNumber: boolean;
}

/** A inbox configuration. */
export class InboxConfig implements IInboxConfig {
    /** Gets or sets a value indicating whether the save to is shown. */
    showSaveTo!: boolean;
    /** Gets or sets a value indicating whether the save is shown. */
    showSave!: boolean;
    /** Gets or sets a value indicating whether the revert is shown. */
    showRevert!: boolean;
    /** Gets or sets a value indicating whether the download is shown. */
    showDownload!: boolean;
    /** Gets or sets a value indicating whether the archive is shown. */
    showArchive!: boolean;
    /** Gets or sets a value indicating whether the rename is shown. */
    showRename!: boolean;
    /** Gets or sets a value indicating whether the merge is shown. */
    showMerge!: boolean;
    /** Gets or sets a value indicating whether the split is shown. */
    showSplit!: boolean;
    /** Gets or sets a value indicating whether the remove is shown. */
    showRemove!: boolean;
    /** Gets or sets a value indicating whether the rotate clockwise is shown. */
    showRotateClockwise!: boolean;
    /** Gets or sets a value indicating whether the rotate anti clockwise is shown. */
    showRotateAntiClockwise!: boolean;
    /** Gets or sets a value indicating whether the select all is shown. */
    showSelectAll!: boolean;
    /** Gets or sets a value indicating whether the unselect is shown. */
    showUnselect!: boolean;
    /** Gets or sets a value indicating whether to archive the original file on save . */
    archiveOriginalFileOnSave!: boolean;
    /** Gets or sets a value indicating whether the document on archive wil be deleted. */
    deleteDocumentOnArchive!: boolean;

    constructor(data?: IInboxConfig) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.showSaveTo = _data["showSaveTo"] !== undefined ? _data["showSaveTo"] : <any>null;
            this.showSave = _data["showSave"] !== undefined ? _data["showSave"] : <any>null;
            this.showRevert = _data["showRevert"] !== undefined ? _data["showRevert"] : <any>null;
            this.showDownload = _data["showDownload"] !== undefined ? _data["showDownload"] : <any>null;
            this.showArchive = _data["showArchive"] !== undefined ? _data["showArchive"] : <any>null;
            this.showRename = _data["showRename"] !== undefined ? _data["showRename"] : <any>null;
            this.showMerge = _data["showMerge"] !== undefined ? _data["showMerge"] : <any>null;
            this.showSplit = _data["showSplit"] !== undefined ? _data["showSplit"] : <any>null;
            this.showRemove = _data["showRemove"] !== undefined ? _data["showRemove"] : <any>null;
            this.showRotateClockwise = _data["showRotateClockwise"] !== undefined ? _data["showRotateClockwise"] : <any>null;
            this.showRotateAntiClockwise = _data["showRotateAntiClockwise"] !== undefined ? _data["showRotateAntiClockwise"] : <any>null;
            this.showSelectAll = _data["showSelectAll"] !== undefined ? _data["showSelectAll"] : <any>null;
            this.showUnselect = _data["showUnselect"] !== undefined ? _data["showUnselect"] : <any>null;
            this.archiveOriginalFileOnSave = _data["archiveOriginalFileOnSave"] !== undefined ? _data["archiveOriginalFileOnSave"] : <any>null;
            this.deleteDocumentOnArchive = _data["deleteDocumentOnArchive"] !== undefined ? _data["deleteDocumentOnArchive"] : <any>null;
        }
    }

    static fromJS(data: any): InboxConfig {
        data = typeof data === 'object' ? data : {};
        let result = new InboxConfig();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["showSaveTo"] = this.showSaveTo !== undefined ? this.showSaveTo : <any>null;
        data["showSave"] = this.showSave !== undefined ? this.showSave : <any>null;
        data["showRevert"] = this.showRevert !== undefined ? this.showRevert : <any>null;
        data["showDownload"] = this.showDownload !== undefined ? this.showDownload : <any>null;
        data["showArchive"] = this.showArchive !== undefined ? this.showArchive : <any>null;
        data["showRename"] = this.showRename !== undefined ? this.showRename : <any>null;
        data["showMerge"] = this.showMerge !== undefined ? this.showMerge : <any>null;
        data["showSplit"] = this.showSplit !== undefined ? this.showSplit : <any>null;
        data["showRemove"] = this.showRemove !== undefined ? this.showRemove : <any>null;
        data["showRotateClockwise"] = this.showRotateClockwise !== undefined ? this.showRotateClockwise : <any>null;
        data["showRotateAntiClockwise"] = this.showRotateAntiClockwise !== undefined ? this.showRotateAntiClockwise : <any>null;
        data["showSelectAll"] = this.showSelectAll !== undefined ? this.showSelectAll : <any>null;
        data["showUnselect"] = this.showUnselect !== undefined ? this.showUnselect : <any>null;
        data["archiveOriginalFileOnSave"] = this.archiveOriginalFileOnSave !== undefined ? this.archiveOriginalFileOnSave : <any>null;
        data["deleteDocumentOnArchive"] = this.deleteDocumentOnArchive !== undefined ? this.deleteDocumentOnArchive : <any>null;
        return data;
    }
}

/** A inbox configuration. */
export interface IInboxConfig {
    /** Gets or sets a value indicating whether the save to is shown. */
    showSaveTo: boolean;
    /** Gets or sets a value indicating whether the save is shown. */
    showSave: boolean;
    /** Gets or sets a value indicating whether the revert is shown. */
    showRevert: boolean;
    /** Gets or sets a value indicating whether the download is shown. */
    showDownload: boolean;
    /** Gets or sets a value indicating whether the archive is shown. */
    showArchive: boolean;
    /** Gets or sets a value indicating whether the rename is shown. */
    showRename: boolean;
    /** Gets or sets a value indicating whether the merge is shown. */
    showMerge: boolean;
    /** Gets or sets a value indicating whether the split is shown. */
    showSplit: boolean;
    /** Gets or sets a value indicating whether the remove is shown. */
    showRemove: boolean;
    /** Gets or sets a value indicating whether the rotate clockwise is shown. */
    showRotateClockwise: boolean;
    /** Gets or sets a value indicating whether the rotate anti clockwise is shown. */
    showRotateAntiClockwise: boolean;
    /** Gets or sets a value indicating whether the select all is shown. */
    showSelectAll: boolean;
    /** Gets or sets a value indicating whether the unselect is shown. */
    showUnselect: boolean;
    /** Gets or sets a value indicating whether to archive the original file on save . */
    archiveOriginalFileOnSave: boolean;
    /** Gets or sets a value indicating whether the document on archive wil be deleted. */
    deleteDocumentOnArchive: boolean;
}

/** A outbox configuration. */
export class OutboxConfig implements IOutboxConfig {
    /** Gets or sets a value indicating whether the restore is shown. */
    showRestore!: boolean;
    /** Gets or sets a value indicating whether the download is shown. */
    showDownload!: boolean;

    constructor(data?: IOutboxConfig) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.showRestore = _data["showRestore"] !== undefined ? _data["showRestore"] : <any>null;
            this.showDownload = _data["showDownload"] !== undefined ? _data["showDownload"] : <any>null;
        }
    }

    static fromJS(data: any): OutboxConfig {
        data = typeof data === 'object' ? data : {};
        let result = new OutboxConfig();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["showRestore"] = this.showRestore !== undefined ? this.showRestore : <any>null;
        data["showDownload"] = this.showDownload !== undefined ? this.showDownload : <any>null;
        return data;
    }
}

/** A outbox configuration. */
export interface IOutboxConfig {
    /** Gets or sets a value indicating whether the restore is shown. */
    showRestore: boolean;
    /** Gets or sets a value indicating whether the download is shown. */
    showDownload: boolean;
}

/** A archive configuration. */
export class ArchiveConfig implements IArchiveConfig {
    /** Gets or sets a value indicating whether the restore is shown. */
    showRestore!: boolean;
    /** Gets or sets a value indicating whether the download is shown. */
    showDownload!: boolean;
    /** Gets or sets a value indicating whether the delete is shown. */
    showDelete!: boolean;

    constructor(data?: IArchiveConfig) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.showRestore = _data["showRestore"] !== undefined ? _data["showRestore"] : <any>null;
            this.showDownload = _data["showDownload"] !== undefined ? _data["showDownload"] : <any>null;
            this.showDelete = _data["showDelete"] !== undefined ? _data["showDelete"] : <any>null;
        }
    }

    static fromJS(data: any): ArchiveConfig {
        data = typeof data === 'object' ? data : {};
        let result = new ArchiveConfig();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["showRestore"] = this.showRestore !== undefined ? this.showRestore : <any>null;
        data["showDownload"] = this.showDownload !== undefined ? this.showDownload : <any>null;
        data["showDelete"] = this.showDelete !== undefined ? this.showDelete : <any>null;
        return data;
    }
}

/** A archive configuration. */
export interface IArchiveConfig {
    /** Gets or sets a value indicating whether the restore is shown. */
    showRestore: boolean;
    /** Gets or sets a value indicating whether the download is shown. */
    showDownload: boolean;
    /** Gets or sets a value indicating whether the delete is shown. */
    showDelete: boolean;
}

export class ProblemDetails implements IProblemDetails {
    type?: string | null;
    title?: string | null;
    status?: number | null;
    detail?: string | null;
    instance?: string | null;
    extensions!: { [key: string]: any; };

    [key: string]: any;

    constructor(data?: IProblemDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.extensions = {};
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.type = _data["type"] !== undefined ? _data["type"] : <any>null;
            this.title = _data["title"] !== undefined ? _data["title"] : <any>null;
            this.status = _data["status"] !== undefined ? _data["status"] : <any>null;
            this.detail = _data["detail"] !== undefined ? _data["detail"] : <any>null;
            this.instance = _data["instance"] !== undefined ? _data["instance"] : <any>null;
            if (_data["extensions"]) {
                this.extensions = {} as any;
                for (let key in _data["extensions"]) {
                    if (_data["extensions"].hasOwnProperty(key))
                        (<any>this.extensions)![key] = _data["extensions"][key] !== undefined ? _data["extensions"][key] : <any>null;
                }
            }
            else {
                this.extensions = <any>null;
            }
        }
    }

    static fromJS(data: any): ProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ProblemDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["type"] = this.type !== undefined ? this.type : <any>null;
        data["title"] = this.title !== undefined ? this.title : <any>null;
        data["status"] = this.status !== undefined ? this.status : <any>null;
        data["detail"] = this.detail !== undefined ? this.detail : <any>null;
        data["instance"] = this.instance !== undefined ? this.instance : <any>null;
        if (this.extensions) {
            data["extensions"] = {};
            for (let key in this.extensions) {
                if (this.extensions.hasOwnProperty(key))
                    (<any>data["extensions"])[key] = this.extensions[key] !== undefined ? this.extensions[key] : <any>null;
            }
        }
        return data;
    }
}

export interface IProblemDetails {
    type?: string | null;
    title?: string | null;
    status?: number | null;
    detail?: string | null;
    instance?: string | null;
    extensions: { [key: string]: any; };

    [key: string]: any;
}

/** A folder. */
export class Folder implements IFolder {
    /** Gets or sets the name. */
    name!: string;
    /** Gets or sets the sub folders. */
    subFolders!: Folder[];

    constructor(data?: IFolder) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.subFolders = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            if (Array.isArray(_data["subFolders"])) {
                this.subFolders = [] as any;
                for (let item of _data["subFolders"])
                    this.subFolders!.push(Folder.fromJS(item));
            }
            else {
                this.subFolders = <any>null;
            }
        }
    }

    static fromJS(data: any): Folder {
        data = typeof data === 'object' ? data : {};
        let result = new Folder();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name !== undefined ? this.name : <any>null;
        if (Array.isArray(this.subFolders)) {
            data["subFolders"] = [];
            for (let item of this.subFolders)
                data["subFolders"].push(item.toJSON());
        }
        return data;
    }
}

/** A folder. */
export interface IFolder {
    /** Gets or sets the name. */
    name: string;
    /** Gets or sets the sub folders. */
    subFolders: Folder[];
}

/** A document. */
export class Document implements IDocument {
    /** Gets or sets the name. */
    name!: string;
    /** Gets or sets the pathname of the directory. */
    directory!: string;
    /** Gets or sets the Date/Time of the created. */
    created!: Date;
    /** Gets or sets the Date/Time of the last modified. */
    lastModified!: Date;
    /** Gets or sets a value indicating whether this object has changes. */
    hasChanges!: boolean;
    /** Gets or sets the document status. */
    status!: DocumentStatus;

    constructor(data?: IDocument) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.directory = _data["directory"] !== undefined ? _data["directory"] : <any>null;
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>null;
            this.lastModified = _data["lastModified"] ? new Date(_data["lastModified"].toString()) : <any>null;
            this.hasChanges = _data["hasChanges"] !== undefined ? _data["hasChanges"] : <any>null;
            this.status = _data["status"] !== undefined ? _data["status"] : <any>null;
        }
    }

    static fromJS(data: any): Document {
        data = typeof data === 'object' ? data : {};
        let result = new Document();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["directory"] = this.directory !== undefined ? this.directory : <any>null;
        data["created"] = this.created ? this.created.toISOString() : <any>null;
        data["lastModified"] = this.lastModified ? this.lastModified.toISOString() : <any>null;
        data["hasChanges"] = this.hasChanges !== undefined ? this.hasChanges : <any>null;
        data["status"] = this.status !== undefined ? this.status : <any>null;
        return data;
    }
}

/** A document. */
export interface IDocument {
    /** Gets or sets the name. */
    name: string;
    /** Gets or sets the pathname of the directory. */
    directory: string;
    /** Gets or sets the Date/Time of the created. */
    created: Date;
    /** Gets or sets the Date/Time of the last modified. */
    lastModified: Date;
    /** Gets or sets a value indicating whether this object has changes. */
    hasChanges: boolean;
    /** Gets or sets the document status. */
    status: DocumentStatus;
}

/** Values that represent document status. 0 = Ok 1 = Corrupted 2 = PasswordProtected */
export enum DocumentStatus {
    Ok = 0,
    Corrupted = 1,
    PasswordProtected = 2,
}

/** Values that represent target directories. 0 = Inbox 1 = Outbox 2 = Archive */
export enum TargetDirectory {
    Inbox = 0,
    Outbox = 1,
    Archive = 2,
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}

}